
# 15_day_challenge
15 days DSA challenge from digg_deepe
=======
# üöÄ Digg_Deeper 15 Days Challenge

Welcome to my **Digg_Deeper 15 Days Challenge**!  
The goal: sharpen my problem-solving and coding skills by solving **3 LeetCode problems a day** for 15 days.

I'll be documenting each day‚Äôs progress right here, along with code solutions and brief notes.

---

## üóìÔ∏è Challenge Duration:
**Start Date:** August 2, 2025  
**End Date:** August 16, 2025  

---

## ‚úÖ Daily Goals:
- Solve **3 LeetCode problems** per day
- Focus on clarity, efficiency, and understanding
- Reflect with notes or improvements

---

## üìò Day 1 - August 2, 2025

**Problems Solved:**
1. [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/)  
   ‚û§ Implemented Kadane‚Äôs Algorithm for optimal performance  
2. [Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)  
   ‚û§ Solved using in-place array manipulation with O(1) extra space  
3. [Two Sum](https://leetcode.com/problems/two-sum/)  
   ‚û§ Used a hashmap for efficient O(n) solution


üß† **Reflection:**  
Solid start! Felt comfortable with array manipulation and hashmap logic. Focus tomorrow: practice a medium difficulty dynamic programming problem.

## üìò Day 2 - August 3, 2025

**Problems Solved:**
1. [Valid Parentheses](https://leetcode.com/problems/valid-parentheses/)  
2. [Two Sum II - Input Array Is Sorted](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/)  
3. [Another Problem Name]  

üß† **Reflection:**  
Example: Focused on using stacks and two-pointer strategies today.


## üìò Day 3 - August 4, 2025

**Problems Solved:**
1. [Valid Anagram (LeetCode 242)](https://leetcode.com/problems/valid-anagram/)  
   ‚û§ Compared sorted strings and used hash maps for optimized checking.  
2. [Find the Index of the First Occurrence in a String (LeetCode 28)](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/)  
   ‚û§ Applied Python's built-in `find()` and also practiced manual sliding window approach.  
3. [Group Anagrams (LeetCode 49)](https://leetcode.com/problems/group-anagrams/)  
   ‚û§ Used a hash map with tuple-sorted keys to group anagrams efficiently.

üß† **Reflection:**  
Focused on string manipulation and hash map use cases today. Grouping anagrams helped solidify understanding of key design using immutable structures like tuples. Feeling more confident with intermediate string problems!

## üìò Day 4 - August 5, 2025

**Problems Solved:**
1. [Subarray Sum Equals K (LeetCode 560)](https://leetcode.com/problems/subarray-sum-equals-k/)  
   ‚û§ Solved using prefix sum and hashmap to achieve O(n) complexity.  
2. [Longest Palindromic Substring (LeetCode 5)](https://leetcode.com/problems/longest-palindromic-substring/)  
   ‚û§ Used expand-around-center approach for O(n¬≤) solution. Also reviewed dynamic programming technique.  
3. [Valid Parentheses (LeetCode 20)](https://leetcode.com/problems/valid-parentheses/)  
   ‚û§ Reinforced stack-based approach for matching brackets.

üß† **Reflection:**  
Today‚Äôs problems required combining hash maps, sliding windows, and stack-based logic. Especially enjoyed solving the palindrome problem by understanding how to expand from the center. Getting better at spotting optimal patterns!

## üìò Day 5 - August 6, 2025

**Problems Solved:**
1. [Binary Search (LeetCode 704)](https://leetcode.com/problems/binary-search/)  
   ‚û§ Implemented classic binary search (iterative and recursive) for sorted arrays.  
2. [Linked List Cycle (LeetCode 141)](https://leetcode.com/problems/linked-list-cycle/)  
   ‚û§ Used Floyd‚Äôs Cycle Detection Algorithm (Tortoise and Hare approach).  
3. [Trapping Rain Water (LeetCode 42)](https://leetcode.com/problems/trapping-rain-water/)  
   ‚û§ Solved using two-pointer approach to optimize space and time.

üß† **Reflection:**  
Covered a wide range of topics today‚Äîsearch algorithms, linked list traversal, and an advanced two-pointer technique for a classic array problem. The rainwater problem was tricky but fun to break down!

üìò Day 6 - August 7, 2025
Problems Solved:

Search Insert Position (LeetCode 35)
‚û§ Used binary search to find the correct insertion point in O(log n) time.

Two Sum II - Input Array Is Sorted (LeetCode 167)
‚û§ Applied the two-pointer technique on a sorted array for optimal performance.

Longest Substring Without Repeating Characters (LeetCode 3)
‚û§ Implemented sliding window approach using a hash set for O(n) solution.

üß† Reflection:
Today was packed with foundational techniques like binary search, two-pointers, and sliding window. These patterns are recurring themes in interviews, and solving them under time constraints helped reinforce clarity and speed. Sliding window problems are becoming more intuitive!

## üìò Day 7 - August 8, 2025
Problems Solved:

132 Pattern (LeetCode 456)
‚û§ Solved using a monotonic stack approach from right to left to achieve O(n) complexity.

Reverse Linked List II (LeetCode 92)
‚û§ Implemented in-place reversal for a sublist between two positions using pointer manipulation.

Sliding Window Maximum (LeetCode 239)
‚û§ Used a deque to maintain the index of potential maximums for each window in O(n) time.

üß† Reflection:
Today‚Äôs problems were a solid mix of stack-based patterns, linked list manipulation, and deque-based sliding window logic. The 132 Pattern was tricky at first but became clear after understanding the reverse iteration approach. Linked list reversal sharpened my pointer skills, and the sliding window maximum reinforced the importance of data structures like deque for efficiency.

üìò Day 8 - August 9, 2025
Problems Solved:

Simplify Path (LeetCode 71)
‚û§ Used a stack to process directory changes (. and ..) and construct the canonical path.

Basic Calculator (LeetCode 224)
‚û§ Implemented using a stack to handle parentheses, signs, and multi-digit numbers in O(n) time.

Decode String (LeetCode 394)
‚û§ Solved using stack-based decoding for nested patterns like "3[a2[c]]".

üß† Reflection:
Today was stack-heavy! From parsing directory paths to decoding nested strings and evaluating expressions, the stack proved to be an indispensable tool for structured, LIFO-based processing. Problems like decodeString were particularly fun and tested my ability to manage multiple data layers.


üìò Day 9 - August 10, 2025
Problems Solved:

Maximum Depth of Binary Tree (LeetCode 104)
‚û§ Solved using both DFS (recursive) and BFS (iterative) approaches to find tree depth.

Container With Most Water (LeetCode 11)
‚û§ Applied two-pointer technique to maximize area in O(n) time.

Subarray Sum Equals K (LeetCode 560)
‚û§ Used prefix sum and hashmap to achieve O(n) solution for counting valid subarrays.

üß† Reflection:
Today was a great mix of tree traversal, two-pointer optimization, and prefix sum with hashing. The tree problem reinforced recursion fundamentals, while the container problem sharpened my pointer movement logic. Prefix sum problems continue to highlight the importance of cumulative computation for efficiency.

üìò Day 10 - August 10, 2025
Problems Solved:

Fibonacci Number (LeetCode 509)
‚û§ Solved using recursion, iteration, and dynamic programming (memoization) for optimal O(n) time.

Climbing Stairs (LeetCode 70)
‚û§ Implemented bottom-up dynamic programming approach (similar to Fibonacci) for O(n) time and O(1) space.

Minimum Depth of Binary Tree (LeetCode 111)
‚û§ Used BFS for shortest path to a leaf node and also explored DFS recursive approach.

üß† Reflection:
Today‚Äôs problems reinforced the relationship between recursion and dynamic programming, especially in Fibonacci and Climbing Stairs. The binary tree problem was a good reminder that BFS is often the most efficient way to find shortest paths in tree-like structures

## üìò Day 11 - August 12, 2025

**Problems Solved:**
1. [Lowest Common Ancestor of a Binary Tree (LeetCode 236)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/)  
   ‚û§ Solved using a recursive DFS approach that returns the node if it matches `p` or `q`, or if each is found in different subtrees. Time complexity: O(n), space: O(h) for recursion stack.

2. [Coin Change (LeetCode 322)](https://leetcode.com/problems/coin-change/)  
   ‚û§ Implemented bottom-up dynamic programming to compute the minimum coins needed for each amount up to the target. Used O(amount) space for optimization.

3. [Number of Islands (LeetCode 200)](https://leetcode.com/problems/number-of-islands/)  
   ‚û§ Used DFS to traverse and mark visited land cells. Alternative BFS approach also noted. Achieved O(m √ó n) time complexity.

---

üß† **Reflection:**  
Covered **three different problem-solving paradigms** today:  
- **Tree DFS** for Lowest Common Ancestor  
- **Dynamic Programming** for Coin Change  
- **Graph traversal** for Number of Islands  

Great mix of recursion, tabulation, and grid-based BFS/DFS. This day helped reinforce switching between algorithmic mindsets depending on problem type.



## üìò Day 12 - August 13, 2025

**Problems Solved:**
1. [Remove Nth Node From End of List (LeetCode 19)](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)  
   ‚û§ Used a two-pointer technique to find the target node in one pass. Maintained a dummy head to simplify edge cases like removing the first node.

2. [Palindrome Linked List (LeetCode 234)](https://leetcode.com/problems/palindrome-linked-list/)  
   ‚û§ Found the middle of the list using fast/slow pointers, reversed the second half, and compared halves in O(n) time and O(1) space.

3. [Intersection of Two Linked Lists (LeetCode 160)](https://leetcode.com/problems/intersection-of-two-linked-lists/)  
   ‚û§ Used the length-difference alignment trick: advanced the longer list‚Äôs pointer until both lists had equal remaining length, then moved both in sync to find intersection.

---

üß† **Reflection:**  
Today was all about **linked list mastery** ‚Äî removing nodes from the end, detecting palindromes, and finding intersection points. Practiced multiple core linked list patterns:  
- Two-pointer traversal  
- Fast/slow pointer for mid-point  
- In-place reversal for memory efficiency  
These problems reinforced clean pointer manipulation and the importance of dummy nodes for elegant edge-case handling.

üìò Day 13 - August 14, 2025

Problems Solved:

Remove All Adjacent Duplicates in String II (LeetCode 1209)
‚û§ Used a stack to store characters along with their frequency, removing them when the count reached k.

Asteroid Collision (LeetCode 735)
‚û§ Simulated collisions using a stack to handle direction and magnitude checks efficiently.

Make The String Great (LeetCode 1544)
‚û§ Leveraged a stack to remove adjacent letters that differ only by case until the string stabilized.

üß† Reflection:
Today was a stack-heavy day! All three problems highlighted how stacks are perfect for handling problems with ‚Äúundo‚Äù or ‚Äúcollapse‚Äù mechanics. Mastering this pattern makes many string and simulation problems much simpler.

## üìÇ Folder Structure:
```bash
üìÅ digg_deeper_15days
‚îú‚îÄ‚îÄ day1/
‚îÇ   ‚îú‚îÄ‚îÄ maximum_subarray.py
‚îÇ   ‚îú‚îÄ‚îÄ remove_duplicates.py
‚îÇ   ‚îî‚îÄ‚îÄ two_sum.py
‚îú‚îÄ‚îÄ day2/
|   ‚îú‚îÄ‚îÄquestion_01.py
|   ‚îú‚îÄ‚îÄquestion_02.py
|   ‚îú‚îÄ‚îÄquestion_03.py
‚îú‚îÄ‚îÄ day3/
|   ‚îú‚îÄ‚îÄquestion_1.py
|   ‚îú‚îÄ‚îÄquestion_2.py
|   ‚îú‚îÄ‚îÄquestion_3.py
‚îú‚îÄ‚îÄ day4/
|   ‚îú‚îÄ‚îÄquestion_01.py
|   ‚îú‚îÄ‚îÄquestion_02.py
|   ‚îú‚îÄ‚îÄquestion_03.py 
‚îú‚îÄ‚îÄ day5/
|   ‚îú‚îÄ‚îÄquestion_01.py
|   ‚îú‚îÄ‚îÄquestion_02.py
|   ‚îú‚îÄ‚îÄquestion_03.py 
‚îú‚îÄ‚îÄ day6/
|   ‚îú‚îÄ‚îÄquestion_1.py
|   ‚îú‚îÄ‚îÄquestion_2.py
|   ‚îú‚îÄ‚îÄquestion_3.py
‚îú‚îÄ‚îÄ day7/
|   ‚îú‚îÄ‚îÄquestion_1.py
|   ‚îú‚îÄ‚îÄquestion_2.py
|   ‚îú‚îÄ‚îÄquestion_3.py
‚îú‚îÄ‚îÄ day8/
|   ‚îú‚îÄ‚îÄquestion_1.py
|   ‚îú‚îÄ‚îÄquestion_2.py
|   ‚îú‚îÄ‚îÄquestion_3.py
‚îú‚îÄ‚îÄ day9/
|   ‚îú‚îÄ‚îÄquestion_1.py
|   ‚îú‚îÄ‚îÄquestion_2.py
|   ‚îú‚îÄ‚îÄquestion_3.py
‚îú‚îÄ‚îÄ day10/
|   ‚îú‚îÄ‚îÄquestion_1.py
|   ‚îú‚îÄ‚îÄquestion_2.py
|   ‚îú‚îÄ‚îÄquestion_3.py
‚îú‚îÄ‚îÄ day11/
|   ‚îú‚îÄ‚îÄquestion_1.py
|   ‚îú‚îÄ‚îÄquestion_2.py
|   ‚îú‚îÄ‚îÄquestion_3.py
‚îú‚îÄ‚îÄ day12/
|   ‚îú‚îÄ‚îÄquestion_1.py
|   ‚îú‚îÄ‚îÄquestion_2.py
|   ‚îú‚îÄ‚îÄquestion_3.py
‚îú‚îÄ‚îÄ day13/
|   ‚îú‚îÄ‚îÄquestion_1.py
|   ‚îú‚îÄ‚îÄquestion_2.py
|   ‚îú‚îÄ‚îÄquestion_3.py
‚îú‚îÄ‚îÄ README.md
